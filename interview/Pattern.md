Патерни проєктування - це рекомендовані підходи та шаблони, які допомагають вирішувати типові проблеми при проєктуванні програмного забезпечення. Вони пропонують стандартні рішення для певних сценаріїв та задач і дозволяють покращити модульність, гнучкість та підтримуваність коду. В Java існує безліч патернів проєктування, але нижче я поясню декілька найпоширеніших:

* ***Патерн Singleton:*** Цей патерн забезпечує, що клас має тільки один екземпляр, і надає глобальну точку доступу до цього екземпляра. Він корисний, коли потрібно мати лише один об'єкт певного класу, наприклад, об'єкт для роботи з базою даних або об'єкт для налаштування програми.
* Патерн Factory:*** Фабричний патерн використовується для створення об'єктів без явного вказівки їхнього класу. Фабричний метод визначає загальний інтерфейс для створення об'єктів, а підкласи визначають конкретну реалізацію цього методу. Цей патерн дозволяє зменшити залежність від конкретних класів і спрощує створення об'єктів.
* ***Патерн Observer:*** Цей патерн використовується для реалізації механізму "спостерігача" і "підписки". У ньому є один об'єкт, який відомий як спостерігач, і декілька об'єктів, які відомі як підписники. Спостерігач відслідковує зміни в підписниках і повідомляє їх про ці зміни. Це дозволяє забезпечити локалізацію змін та спрощує зв'язок між об'єктами.
* ***Патерн MVC (Model-View-Controller):*** Цей патерн використовується для розділення логіки програми на три компоненти: модель (Model), представлення (View) та контролер (Controller). Модель представляє дані та бізнес-логіку, представлення відповідає за візуалізацію даних, а контролер обробляє взаємодію користувача з програмою. Це дозволяє забезпечити легку модифікацію та розширення програми.
* ***Патерн Builder:*** Цей патерн використовується для конструювання складних об'єктів шляхом послідовного додавання до них частин. Він дозволяє створити об'єкт з багатьох кроків конфігурації, не забруднюючи код конструктора об'єкта. Це особливо корисно, коли конфігурація об'єкта може бути змінна або складною.
* ***Патерн Decorator:*** Цей патерн дозволяє динамічно додавати нові функціональні можливості до існуючих об'єктів, не змінюючи їхньої структури. Він працює за допомогою обгортання об'єктів в додаткові об'єкти, які надають додаткові функції. Це дозволяє гнучко розширювати функціональність об'єктів.
 


Патерн стратегії (Strategy pattern) 

має кілька функцій, які роблять його унікальним і корисним у розробці програмного забезпечення:

Розділення алгоритму від його використання: Цей патерн дозволяє виділити різні алгоритми в окремі класи, що реалізують спільний інтерфейс. Таким чином, алгоритм може бути використаний незалежно від клієнта, який його викликає. Це забезпечує велику гнучкість і можливість замінити алгоритм на інший без змін в клієнтському коді.

Замінюваність стратегій: Патерн стратегії дозволяє динамічно заміняти стратегії, не змінюючи клієнтський код. Це дає змогу легко змінювати поведінку об'єкта, вибираючи підходящу стратегію залежно від поточних потреб або умов. Наприклад, в залежності від контексту виконання можна вибрати різні стратегії обробки даних.

Гнучкість і розширюваність: Патерн стратегії дозволяє легко додавати нові стратегії, не змінюючи існуючий код. Це дає змогу розширювати функціональність системи, додавати нові алгоритми або змінювати існуючі, без необхідності модифікації багатьох класів.

Зменшення залежностей: Використання патерна стратегії дозволяє зменшити залежності між класами. Клієнтський код залежить від абстрактного інтерфейсу стратегії, а не від конкретних реалізацій. Це дозволяє заміняти стратегії без впливу на інші класи системи.

Унікальність патерна стратегії полягає в його спрощенні розробки, розділенні алгоритмів від клієнтського коду, гнучкості заміни стратегій та можливості розширення системи без необхідності модифікації багатьох класів. Використання цього патерна дозволяє створити більш ефективну, модульну та розширювану систему програмного забезпечення.

# Паттерн стратегії (Strategy pattern) в Java є поведінковим патерном проектування, який дозволяє визначити різні алгоритми або стратегії і використовувати їх незалежно від клієнта, який їх викликає. В основі цього патерну лежить ідея розділення алгоритму від його використання.

Патерн стратегії використовується, коли потрібно замінити або розширити певний алгоритм у динамічний спосіб. Він дозволяє легко змінювати поведінку об'єкту, вибираючи підходящу стратегію в залежності від поточних потреб або умов.

Основна ідея полягає в тому, що ви виділяєте окремі класи для кожної стратегії, які реалізують спільний інтерфейс. Клас, що використовує стратегію (клієнт), не залежить від конкретної реалізації стратегії, а працює через спільний інтерфейс. Коли потрібно змінити алгоритм, ви можете просто замінити використовувану стратегію на іншу, не змінюючи клієнтський код.

Використання паттерна стратегії дозволяє досягти гнучкості, розширюваності та зменшення залежності між класами. Він часто використовується в ситуаціях, коли потрібно мати можливість варіювати алгоритм або поведінку об'єкта на льоту без модифікації його коду.



#Статичний фабричний метод (Static Factory Method) - це патерн проектування, який використовує статичний метод для створення об'єктів певного класу. У звичайному фабричному методі, фабричний метод визивається на об'єкті фабрики, тоді як у статичному фабричному методі, метод є статичним, тобто викликається на самому класі.

Основна ідея статичного фабричного методу - це надати зручний і контрольований механізм для створення об'єктів, використовуючи статичний метод замість публічного конструктора. Деякі переваги використання статичного фабричного методу включають:

Назви конструкторів можуть бути неявними або менш очевидними, тоді як статичні фабричні методи можуть мати зрозумілі назви, що полегшує їх використання.

Можливість керувати процесом створення об'єктів, наприклад, за допомогою кешування або повторного використання об'єктів.

Здатність повертати підтипи класу, що неможливо зробити за допомогою конструкторів.

Фабричні методи можуть бути використані для реалізації різних патернів проектування, таких як Singleton, Flyweight, Factory Method та інші.

Використання статичних фабричних методів дозволяє більш гнучко керувати процесом створення об'єктів і покращує загальну організацію коду в програмі.




User.of - це приклад статичного фабричного методу, який може використовуватись для створення об'єктів типу User. Цей метод зазвичай визивається на класі User, а не на об'єкті.

Переваги використання User.of:

Чіткість: Метод User.of може мати зрозумілу назву, яка вказує на те, що саме створюється. Наприклад, User.of("John", "Doe") може створювати об'єкт користувача з іменем "John" та прізвищем "Doe".

Іммутабельність: Статичний фабричний метод може створювати іммутабельні об'єкти, тобто об'єкти, які не можуть бути змінені після створення. Це може забезпечити більшу безпеку та стійкість програми.

Кешування: Метод User.of може використовувати кешування для повернення існуючих об'єктів замість створення нових, якщо вони вже існують. Це може поліпшити продуктивність і зменшити використання пам'яті.

Підтипи: Статичний фабричний метод може повертати підтипи класу User, що дозволяє більш гнучко управляти типами повернутих об'єктів.

Приклад використання User.of:

```java
Copy code
public class User {
    private final String firstName;
    private final String lastName;

    private User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public static User of(String firstName, String lastName) {
        return new User(firstName, lastName);
    }
}
```
// Використання методу User.of для створення об'єкта користувача
User user = User.of("John", "Doe");
У цьому прикладі метод User.of створює новий об'єкт User з вказаними ім'ям і прізвищем.
