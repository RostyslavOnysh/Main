Патерни проєктування - це рекомендовані підходи та шаблони, які допомагають вирішувати типові проблеми при проєктуванні програмного забезпечення. Вони пропонують стандартні рішення для певних сценаріїв та задач і дозволяють покращити модульність, гнучкість та підтримуваність коду. В Java існує безліч патернів проєктування, але нижче я поясню декілька найпоширеніших:

* ***Патерн Singleton:*** Цей патерн забезпечує, що клас має тільки один екземпляр, і надає глобальну точку доступу до цього екземпляра. Він корисний, коли потрібно мати лише один об'єкт певного класу, наприклад, об'єкт для роботи з базою даних або об'єкт для налаштування програми.
* ***Патерн Factory:*** Фабричний патерн використовується для створення об'єктів без явного вказівки їхнього класу. Фабричний метод визначає загальний інтерфейс для створення об'єктів, а підкласи визначають конкретну реалізацію цього методу. Цей патерн дозволяє зменшити залежність від конкретних класів і спрощує створення об'єктів.
* ***Патерн Observer:*** Цей патерн використовується для реалізації механізму "спостерігача" і "підписки". У ньому є один об'єкт, який відомий як спостерігач, і декілька об'єктів, які відомі як підписники. Спостерігач відслідковує зміни в підписниках і повідомляє їх про ці зміни. Це дозволяє забезпечити локалізацію змін та спрощує зв'язок між об'єктами.
* ***Патерн MVC (Model-View-Controller):*** Цей патерн використовується для розділення логіки програми на три компоненти: модель (Model), представлення (View) та контролер (Controller). Модель представляє дані та бізнес-логіку, представлення відповідає за візуалізацію даних, а контролер обробляє взаємодію користувача з програмою. Це дозволяє забезпечити легку модифікацію та розширення програми.
* ***Патерн Builder:*** Цей патерн використовується для конструювання складних об'єктів шляхом послідовного додавання до них частин. Він дозволяє створити об'єкт з багатьох кроків конфігурації, не забруднюючи код конструктора об'єкта. Це особливо корисно, коли конфігурація об'єкта може бути змінна або складною.
* ***Патерн Decorator:*** Цей патерн дозволяє динамічно додавати нові функціональні можливості до існуючих об'єктів, не змінюючи їхньої структури. Він працює за допомогою обгортання об'єктів в додаткові об'єкти, які надають додаткові функції. Це дозволяє гнучко розширювати функціональність об'єктів.

# Паттерн Builder є одним з паттернів проектування, який використовується для створення складних об'єктів крок за кроком. Цей паттерн розділяє процес конструювання об'єкта від його представлення, що дозволяє побудувати різні варіації об'єкта з одного і того ж коду будівника.

Основні компоненти паттерна Builder:

Builder: Це інтерфейс або абстрактний клас, який описує методи для будівництва кожної частини об'єкта.

ConcreteBuilder: Це клас, який реалізує інтерфейс Builder і забезпечує конкретну реалізацію методів будівника. Він збирає і зберігає частини об'єкта і надає метод для отримання готового об'єкта.

Director: Це клас, який використовує об'єкт будівника для покрокового побудови об'єкта. Він встановлює порядок виконання кроків будівництва.

Product: Це кінцевий об'єкт, який будується за допомогою будівника. Це може бути складний об'єкт з багатьма частинами або простий об'єкт.

Переваги використання паттерна Builder:

Забезпечує гнучкість побудови об'єктів, дозволяючи створювати різні конфігурації об'єктів.

Розділяє процес будівництва від представлення об'єкта, що спрощує код будівника і дозволяє змінювати його без змінення самого об'єкта.

Дозволяє покроково будувати об'єкти, контролювати порядок виконання кроків і уникати неповних або некоректних станів об'єктів.

Забезпечує можливість створення імутабельних об'єктів, які не можуть бути змінені після будівництва.

Приклад використання паттерна Builder:

```java
public class User {
    private final String firstName;
    private final String lastName;
    private final int age;

    private User(UserBuilder builder) {
        this.firstName = builder.firstName;
        this.lastName = builder.lastName;
        this.age = builder.age;
    }

    public static class UserBuilder {
        private final String firstName;
        private final String lastName;
        private int age;

        public UserBuilder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }

    // Геттери для полів класу User
    // ...
}
```

```
// Використання паттерна Builder для створення об'єкта користувача
User user = new User.UserBuilder("John", "Doe")
                .setAge(30)
                .build();
```
У цьому прикладі ми використовуємо паттерн Builder для створення об'єкта користувача (User). Клас User має внутрішній клас UserBuilder, який визначає методи для крокового будівництва об'єкта. Покроково задаються значення для полів firstName, lastName та age, а потім викликається метод build(), який повертає готовий об'єкт User.




У Java є декілька бібліотек, які надають анотацію @Builder для автоматичного створення класу Builder. Одна з найпопулярніших бібліотек це Project Lombok.

Project Lombok - це бібліотека для Java, яка надає анотації для автоматичного генерування коду, такого як геттери, сеттери, конструктори і багато іншого. Однією з анотацій, яку надає Lombok, є @Builder.

Анотація @Builder може бути застосована до класу або до конструктору класу і дозволяє автоматично створити клас Builder для створення об'єктів з складними параметрами. Вона генерує методи для кожного поля класу, які дозволяють задавати значення для цих полів.

Ось приклад використання анотації @Builder з Project Lombok:

```java
import lombok.Builder;
import lombok.Getter;

@Getter
@Builder
public class User {
    private String firstName;
    private String lastName;
    private int age;
}
```
```
// Використання анотації @Builder для створення об'єкта користувача
User user = User.builder()
                .firstName("John")
                .lastName("Doe")
                .age(30)
                .build();
```
У цьому прикладі анотація @Builder застосовується до класу User. Вона автоматично генерує клас Builder для User, який має методи для задання значень полів. Потім за допомогою цього класу Builder ми можемо побудувати об'єкт User зі зазначеними параметрами.

Project Lombok - це лише одна з багатьох бібліотек, які надають підтримку анотації @Builder. Інші бібліотеки, такі як Immutables і AutoValue, також надають подібні можливості для автоматичного генерування класу Builder.




В методі build() зазвичай вказується this для передачі поточного стану об'єкта Builder в конструктор класу, який ми будуємо.

Коли ми викликаємо метод build(), об'єкт Builder має всі необхідні значення полів, які були задані під час виклику методів-сеттерів на Builder. Щоб створити об'єкт класу, ми можемо викликати конструктор класу і передати поточний стан об'єкта Builder, використовуючи this.

Отже, вказування this у методі build() дозволяє передати поточний стан об'єкта Builder в конструктор класу, щоб створити об'єкт з встановленими значеннями полів.

Ось приклад, що демонструє використання this у методі build():

```java
 
public class Car {
    private String brand;
    private String model;
    // інші поля

    public Car(Builder builder) {
        this.brand = builder.brand;
        this.model = builder.model;
        // ініціалізація інших полів
    }

    public static class Builder {
        private String brand;
        private String model;
        // інші поля

        public Builder brand(String brand) {
            this.brand = brand;
            return this;
        }

        public Builder model(String model) {
            this.model = model;
            return this;
        }

        public Car build() {
            return new Car(this);
        }
    }
}
```
// Використання класу Builder для побудови об'єкта Car
Car car = new Car.Builder()
                .brand("BMW")
                .model("X5")
                .build();

У цьому прикладі, коли ми викликаємо build(), ми створюємо новий об'єкт Car і передаємо поточний стан об'єкта Builder в конструктор Car. Таким чином, в конструкторі Car ми можемо встановити значення полів з об'єкта Builder.
 


Патерн стратегії (Strategy pattern) 

має кілька функцій, які роблять його унікальним і корисним у розробці програмного забезпечення:

Розділення алгоритму від його використання: Цей патерн дозволяє виділити різні алгоритми в окремі класи, що реалізують спільний інтерфейс. Таким чином, алгоритм може бути використаний незалежно від клієнта, який його викликає. Це забезпечує велику гнучкість і можливість замінити алгоритм на інший без змін в клієнтському коді.

Замінюваність стратегій: Патерн стратегії дозволяє динамічно заміняти стратегії, не змінюючи клієнтський код. Це дає змогу легко змінювати поведінку об'єкта, вибираючи підходящу стратегію залежно від поточних потреб або умов. Наприклад, в залежності від контексту виконання можна вибрати різні стратегії обробки даних.

Гнучкість і розширюваність: Патерн стратегії дозволяє легко додавати нові стратегії, не змінюючи існуючий код. Це дає змогу розширювати функціональність системи, додавати нові алгоритми або змінювати існуючі, без необхідності модифікації багатьох класів.

Зменшення залежностей: Використання патерна стратегії дозволяє зменшити залежності між класами. Клієнтський код залежить від абстрактного інтерфейсу стратегії, а не від конкретних реалізацій. Це дозволяє заміняти стратегії без впливу на інші класи системи.

Унікальність патерна стратегії полягає в його спрощенні розробки, розділенні алгоритмів від клієнтського коду, гнучкості заміни стратегій та можливості розширення системи без необхідності модифікації багатьох класів. Використання цього патерна дозволяє створити більш ефективну, модульну та розширювану систему програмного забезпечення.

# Паттерн стратегії (Strategy pattern) в Java є поведінковим патерном проектування, який дозволяє визначити різні алгоритми або стратегії і використовувати їх незалежно від клієнта, який їх викликає. В основі цього патерну лежить ідея розділення алгоритму від його використання.

Патерн стратегії використовується, коли потрібно замінити або розширити певний алгоритм у динамічний спосіб. Він дозволяє легко змінювати поведінку об'єкту, вибираючи підходящу стратегію в залежності від поточних потреб або умов.

Основна ідея полягає в тому, що ви виділяєте окремі класи для кожної стратегії, які реалізують спільний інтерфейс. Клас, що використовує стратегію (клієнт), не залежить від конкретної реалізації стратегії, а працює через спільний інтерфейс. Коли потрібно змінити алгоритм, ви можете просто замінити використовувану стратегію на іншу, не змінюючи клієнтський код.

Використання паттерна стратегії дозволяє досягти гнучкості, розширюваності та зменшення залежності між класами. Він часто використовується в ситуаціях, коли потрібно мати можливість варіювати алгоритм або поведінку об'єкта на льоту без модифікації його коду.



#Статичний фабричний метод (Static Factory Method) - це патерн проектування, який використовує статичний метод для створення об'єктів певного класу. У звичайному фабричному методі, фабричний метод визивається на об'єкті фабрики, тоді як у статичному фабричному методі, метод є статичним, тобто викликається на самому класі.

Основна ідея статичного фабричного методу - це надати зручний і контрольований механізм для створення об'єктів, використовуючи статичний метод замість публічного конструктора. Деякі переваги використання статичного фабричного методу включають:

Назви конструкторів можуть бути неявними або менш очевидними, тоді як статичні фабричні методи можуть мати зрозумілі назви, що полегшує їх використання.

Можливість керувати процесом створення об'єктів, наприклад, за допомогою кешування або повторного використання об'єктів.

Здатність повертати підтипи класу, що неможливо зробити за допомогою конструкторів.

Фабричні методи можуть бути використані для реалізації різних патернів проектування, таких як Singleton, Flyweight, Factory Method та інші.

Використання статичних фабричних методів дозволяє більш гнучко керувати процесом створення об'єктів і покращує загальну організацію коду в програмі.




User.of - це приклад статичного фабричного методу, який може використовуватись для створення об'єктів типу User. Цей метод зазвичай визивається на класі User, а не на об'єкті.

Переваги використання User.of:

Чіткість: Метод User.of може мати зрозумілу назву, яка вказує на те, що саме створюється. Наприклад, User.of("John", "Doe") може створювати об'єкт користувача з іменем "John" та прізвищем "Doe".

Іммутабельність: Статичний фабричний метод може створювати іммутабельні об'єкти, тобто об'єкти, які не можуть бути змінені після створення. Це може забезпечити більшу безпеку та стійкість програми.

Кешування: Метод User.of може використовувати кешування для повернення існуючих об'єктів замість створення нових, якщо вони вже існують. Це може поліпшити продуктивність і зменшити використання пам'яті.

Підтипи: Статичний фабричний метод може повертати підтипи класу User, що дозволяє більш гнучко управляти типами повернутих об'єктів.

Приклад використання User.of:

```java
public class User {
    private final String firstName;
    private final String lastName;

    private User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public static User of(String firstName, String lastName) {
        return new User(firstName, lastName);
    }
}
```
// Використання методу User.of для створення об'єкта користувача
User user = User.of("John", "Doe");
У цьому прикладі метод User.of створює новий об'єкт User з вказаними ім'ям і прізвищем.
